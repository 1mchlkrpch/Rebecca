/* This file is
Similar to YACC-file you can define variables by value in
double quotes and it will be value that will compare with
types in token sequence.*/

// Token names type.
identifier = "TOKEN_NAME";
// First rule that we should try to parse
start = "translation_unit";

additive_expression
	: identifier '+' additive_expression
	| identifier '-' additive_expression
	| identifier
	;

/* Ever time parser try to apply rule it checks how many tokens
were parsed via particular rule.
If 'n_parsed'-tokens is positive number that means that rule will
successfuly applied to sequence of tokens.*/
translation_unit
	: additive_expression ';' translation_unit
	| additive_expression ';'
	;


/* How it works?
1. Parser check if the expression in particular line can be applied
   to token sequence + current_token_idx.

		- If rule was successfully applied (token in sequence has
		  correct txt data or type) so this rule is correct.

		- If line is not good pattern we move to the next line
		  of particular grammar rule until we meet needed one.

2. Sometimes parser's grammar rule comprise
   recursive expressions.
   For example 'translation_unit': it means that
   one file can comprise one or several additive_expression-s.

   For example file:
   a + b;
   b - c;

   Firstly parser will try to parse it as 'translation_unit > additive_expression'.
   It will be successfully parsed but cursor in file will be here (denoted as '*'):
   a + b;*
   b - c;

   So if the parser realize that 'start'-rule parse only part of file
   it will also execute next line in rule 'translation_unit'.*/